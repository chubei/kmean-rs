use crate::{KMeans, KMeansState, memory::*};
use packed_simd::{Simd, SimdArray};
use rand::prelude::*;
use rayon::prelude::*;

pub(crate) struct Minibatch<T> where T: Primitive, [T;LANES]: SimdArray, Simd<[T;LANES]>: SimdWrapper<T>{
	_p: std::marker::PhantomData<T>
}
impl<T> Minibatch<T> where T: Primitive, [T;LANES]: SimdArray, Simd<[T;LANES]>: SimdWrapper<T> {
	fn update_cluster_assignments<'a>(data: &KMeans<T>, state: &mut KMeansState<T>, batch_mask: &[bool], limit_k: Option<usize>) {
		let centroids = &state.centroids;
		let k = limit_k.unwrap_or(state.k);

		data.p_samples.par_chunks_exact(data.p_sample_dims)
			.zip(state.assignments.par_iter_mut())
			.zip(state.centroid_distances.par_iter_mut())
			.zip(batch_mask.par_iter().cloned())
			.for_each(|(((s, assignment), centroid_dist), mask)| {
				if mask { // Element has been randomly voted into the batch
					let (best_idx, best_dist) = centroids.chunks_exact(data.p_sample_dims).take(k)
						.map(|c| {
							s.chunks_exact(LANES).map(|i| unsafe { Simd::<[T;LANES]>::from_slice_aligned_unchecked(i) })
								.zip(c.chunks_exact(LANES).map(|i| unsafe { Simd::<[T;LANES]>::from_slice_aligned_unchecked(i) }))
									.map(|(sp,cp)| sp - cp)         // <sample> - <centroid>
									.map(|v| v * v)                 // <vec_components> ^2
									.sum::<Simd::<[T;LANES]>>()     // sum(<vec_components>^2)
									.sum()
						}).enumerate()
						.min_by(|(_,d0), (_,d1)| d0.partial_cmp(d1).unwrap()).unwrap();
					*assignment = best_idx;
					*centroid_dist = best_dist;
				}
			});
	}

	fn update_centroids(data: &KMeans<T>, state: &mut KMeansState<T>, batch_mask: &[bool]) -> T {
		let centroid_frequency = &mut state.centroid_frequency;
		let centroids = &mut state.centroids;
		let assignments = &state.assignments;

		data.p_samples.chunks_exact(data.p_sample_dims)
			.zip(assignments.iter().cloned())
			.zip(batch_mask.iter().cloned())
			.for_each(|((sample, assignment),mask)| {
				if mask {
					centroid_frequency[assignment] += 1;
					let learn_rate = T::one() / T::from(centroid_frequency[assignment]).unwrap();
					let inv_learn_rate = T::one() - learn_rate;
					centroids.iter_mut().skip(assignment * data.p_sample_dims).take(data.p_sample_dims)
						.zip(sample.iter().cloned())
						.for_each(|(c, s)| {
							*c = inv_learn_rate * *c + learn_rate * s;
						});
				}
			});
		
		state.centroid_distances.iter().cloned().sum()
	}

	pub fn calculate<'a, F>(data: &KMeans<T>, batch_size: usize, k: usize, max_iter: usize, init: F, rnd: &'a mut dyn RngCore) -> KMeansState<T>
				where for<'b> F: FnOnce(&KMeans<T>, &mut KMeansState<T>, &'b mut dyn RngCore) {
		assert!(k <= data.sample_cnt);

		let mut state = KMeansState::new(data.sample_cnt, data.p_sample_dims, k);
        state.distsum = T::infinity();
		// Count how many times, the distsum did not improve, exit after 5 iterations without improvement
		let mut improvement_counter = 0;

		// Initialize clusters
		init(&data, &mut state, rnd);

		for _ in 1..=max_iter {
			// Shuffle and get a random batch (of approximately the size batch_size)
			let selection_chance = 1.0f32 / batch_size as f32;
			let mut batch_mask = vec![false;data.sample_cnt];
			batch_mask.iter_mut().for_each(|b| *b = rnd.gen_range(0.0f32, 1.0f32) < selection_chance);

			Self::update_cluster_assignments(data, &mut state, &batch_mask, None);
			let new_distsum = Self::update_centroids(data, &mut state, &batch_mask);

            if (state.distsum - new_distsum) < T::from(0.0005).unwrap() {
				improvement_counter += 1;
				if improvement_counter == 5 { // exit after 5 iterations without improvement
					break;
				}
            } else {
				improvement_counter = 0;
			}
            state.distsum = new_distsum;
		}

		data.update_cluster_assignments(&mut state, None);

		let (assignments, centroid_frequency, centroid_distances, distsum) =
			(&state.assignments, &mut state.centroid_frequency, &mut state.centroid_distances, &mut state.distsum);
		let mut non_empty_clusters = state.k;
		rayon::scope(|s| {
			s.spawn(|_| {
				non_empty_clusters -= data.update_cluster_frequencies(assignments, centroid_frequency);
			});
			s.spawn(|_| {
				*distsum = centroid_distances.iter().cloned().sum();
			});
		});
		state.remove_padding(data.sample_dims)
	}
}




#[cfg(test)]
mod tests {
	use super::*;

	#[test]
    fn iris_dataset_f64() where {
        let samples = vec![1.4f64, 0.2, 1.4, 0.2, 1.3, 0.2, 1.5, 0.2, 1.4, 0.2, 1.7, 0.4, 1.4, 0.3, 1.5, 0.2, 1.4, 0.2, 1.5, 0.1, 1.5, 0.2, 1.6, 0.2, 1.4, 0.1, 1.1, 0.1, 1.2, 0.2, 1.5, 0.4, 1.3, 0.4, 1.4, 0.3, 1.7, 0.3, 1.5, 0.3, 1.7, 0.2, 1.5, 0.4, 1.0, 0.2, 1.7, 0.5, 1.9, 0.2, 1.6, 0.2, 1.6, 0.4, 1.5, 0.2, 1.4, 0.2, 1.6, 0.2, 1.6, 0.2, 1.5, 0.4, 1.5, 0.1, 1.4, 0.2, 1.5, 0.2, 1.2, 0.2, 1.3, 0.2, 1.4, 0.1, 1.3, 0.2, 1.5, 0.2, 1.3, 0.3, 1.3, 0.3, 1.3, 0.2, 1.6, 0.6, 1.9, 0.4, 1.4, 0.3, 1.6, 0.2, 1.4, 0.2, 1.5, 0.2, 1.4, 0.2, 4.7, 1.4, 4.5, 1.5, 4.9, 1.5, 4.0, 1.3, 4.6, 1.5, 4.5, 1.3, 4.7, 1.6, 3.3, 1.0, 4.6, 1.3, 3.9, 1.4, 3.5, 1.0, 4.2, 1.5, 4.0, 1.0, 4.7, 1.4, 3.6, 1.3, 4.4, 1.4, 4.5, 1.5, 4.1, 1.0, 4.5, 1.5, 3.9, 1.1, 4.8, 1.8, 4.0, 1.3, 4.9, 1.5, 4.7, 1.2, 4.3, 1.3, 4.4, 1.4, 4.8, 1.4, 5.0, 1.7, 4.5, 1.5, 3.5, 1.0, 3.8, 1.1, 3.7, 1.0, 3.9, 1.2, 5.1, 1.6, 4.5, 1.5, 4.5, 1.6, 4.7, 1.5, 4.4, 1.3, 4.1, 1.3, 4.0, 1.3, 4.4, 1.2, 4.6, 1.4, 4.0, 1.2, 3.3, 1.0, 4.2, 1.3, 4.2, 1.2, 4.2, 1.3, 4.3, 1.3, 3.0, 1.1, 4.1, 1.3, 6.0, 2.5, 5.1, 1.9, 5.9, 2.1, 5.6, 1.8, 5.8, 2.2, 6.6, 2.1, 4.5, 1.7, 6.3, 1.8, 5.8, 1.8, 6.1, 2.5, 5.1, 2.0, 5.3, 1.9, 5.5, 2.1, 5.0, 2.0, 5.1, 2.4, 5.3, 2.3, 5.5, 1.8, 6.7, 2.2, 6.9, 2.3, 5.0, 1.5, 5.7, 2.3, 4.9, 2.0, 6.7, 2.0, 4.9, 1.8, 5.7, 2.1, 6.0, 1.8, 4.8, 1.8, 4.9, 1.8, 5.6, 2.1, 5.8, 1.6, 6.1, 1.9, 6.4, 2.0, 5.6, 2.2, 5.1, 1.5, 5.6, 1.4, 6.1, 2.3, 5.6, 2.4, 5.5, 1.8, 4.8, 1.8, 5.4, 2.1, 5.6, 2.4, 5.1, 2.3, 5.1, 1.9, 5.9, 2.3, 5.7, 2.5, 5.2, 2.3, 5.0, 1.9, 5.2, 2.0, 5.4, 2.3, 5.1, 1.8];

        let kmean = KMeans::new(samples, 150, 2);
        let mut rnd = rand::rngs::StdRng::seed_from_u64(1);
        let res = kmean.kmeans_minibatch(30, 3, 100, KMeans::init_kmeanplusplus, &mut rnd);

        // SHOULD solution
        let should_assignments = vec![1usize, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 0, 2, 0, 2, 0, 2, 2, 0, 0, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 0];
        let should_centroid_distances = vec![0.004669128962757853, 0.004669128962757853, 0.024844567559249204, 0.004493690366266468, 0.004669128962757853, 0.08589719913819599, 0.005546321945213996, 0.004493690366266468, 0.004669128962757853, 0.023616497383810324, 0.004493690366266468, 0.02431825176977512, 0.02379193598030171, 0.14431825176977575, 0.06502000615574062, 0.02624807633117876, 0.0465989535241615, 0.005546321945213996, 0.06502000615573984, 0.0053708833487226115, 0.0641428131732837, 0.02624807633117876, 0.20537088334872333, 0.1267743921206521, 0.20379193598030088, 0.02431825176977512, 0.046072637734687415, 0.004493690366266468, 0.004669128962757853, 0.02431825176977512, 0.02431825176977512, 0.02624807633117876, 0.023616497383810324, 0.004669128962757853, 0.004493690366266468, 0.06502000615574062, 0.024844567559249204, 0.02379193598030171, 0.024844567559249204, 0.004493690366266468, 0.025721760541705347, 0.025721760541705347, 0.024844567559249204, 0.14782702369959969, 0.22554632194521318, 0.005546321945213996, 0.02431825176977512, 0.004669128962757853, 0.004493690366266468, 0.004669128962757853, 0.05834773963152318, 0.0028522441360278403, 0.1902396315234149, 0.24222161350539811, 0.019699090982874434, 0.02645584773963155, 0.07474413602791946, 1.5696990909828772, 0.043302694586478147, 0.3235729648567497, 1.1433927846765701, 0.07231170359548768, 0.4276270189108037, 0.05834773963152318, 0.7748342261180112, 0.007807199090982979, 0.0028522441360278403, 0.34447386575765065, 0.0028522441360278403, 0.44897837026215526, 0.22798737927116222, 0.24222161350539811, 0.1902396315234149, 0.12195134323512691, 0.05276215404593823, 0.007807199090982979, 0.11519458647836965, 0.3434828747666575, 0.0028522441360278403, 1.1433927846765701, 0.5721315234153087, 0.7970864783702634, 0.3871765684603534, 0.42213152341530563, 0.0028522441360278403, 0.021050442334226004, 0.0565459378297213, 0.029609000892784815, 0.15906846035224506, 0.24222161350539811, 0.07141080269458672, 0.021500892784676307, 0.2840234153072, 1.5696990909828772, 0.09591530719909139, 0.1377171090008933, 0.09591530719909139, 0.05276215404593823, 2.277356748640535, 0.15906846035224506, 0.2121759999999981, 0.5493760000000041, 0.006975999999999664, 0.1245760000000018, 0.015775999999999787, 0.6089759999999962, 0.05924864053242409, 0.3065759999999986, 0.07657600000000084, 0.25817599999999746, 0.5241760000000038, 0.3013760000000028, 0.10297600000000126, 0.578077469361252, 0.6233760000000026, 0.3205760000000016, 0.17857600000000207, 0.7897759999999964, 1.2165759999999957, 0.2870864783702613, 0.06457599999999974, 0.4812306225144056, 0.7801759999999969, 0.30483422611800937, 0.01497600000000039, 0.108576, 0.22798737927116222, 0.30483422611800937, 0.048976000000001, 0.22697600000000134, 0.10937599999999917, 0.34217599999999826, 0.06377600000000076, 0.4039333252171075, 0.505376000000003, 0.12857599999999794, 0.1533760000000001, 0.17857600000000207, 0.22798737927116222, 0.17697600000000138, 0.1533760000000001, 0.5685760000000029, 0.5493760000000041, 0.056575999999999016, 0.19417599999999927, 0.4345760000000016, 0.47987927116305373, 0.3901760000000026, 0.22657600000000072, 0.5185279198117019];
        let should_centroids = vec![4.465765765765767, 1.4590090090090093, 1.4508771929824569, 0.24561403508771928, 5.820000000000002, 2.0760000000000014];
		let should_centroid_frequency = vec![61, 50, 39];

        assert_eq!(res.distsum, 33.33203156992827);
        assert_eq!(res.sample_dims, LANES);
        assert_eq!(res.assignments, should_assignments);
        assert_eq!(res.centroid_distances, should_centroid_distances);
        assert_eq!(res.centroids, should_centroids);
		assert_eq!(res.centroid_frequency, should_centroid_frequency);
    }

    #[test]
    fn iris_dataset_f32() where {
        let samples = vec![1.4f32, 0.2, 1.4, 0.2, 1.3, 0.2, 1.5, 0.2, 1.4, 0.2, 1.7, 0.4, 1.4, 0.3, 1.5, 0.2, 1.4, 0.2, 1.5, 0.1, 1.5, 0.2, 1.6, 0.2, 1.4, 0.1, 1.1, 0.1, 1.2, 0.2, 1.5, 0.4, 1.3, 0.4, 1.4, 0.3, 1.7, 0.3, 1.5, 0.3, 1.7, 0.2, 1.5, 0.4, 1.0, 0.2, 1.7, 0.5, 1.9, 0.2, 1.6, 0.2, 1.6, 0.4, 1.5, 0.2, 1.4, 0.2, 1.6, 0.2, 1.6, 0.2, 1.5, 0.4, 1.5, 0.1, 1.4, 0.2, 1.5, 0.2, 1.2, 0.2, 1.3, 0.2, 1.4, 0.1, 1.3, 0.2, 1.5, 0.2, 1.3, 0.3, 1.3, 0.3, 1.3, 0.2, 1.6, 0.6, 1.9, 0.4, 1.4, 0.3, 1.6, 0.2, 1.4, 0.2, 1.5, 0.2, 1.4, 0.2, 4.7, 1.4, 4.5, 1.5, 4.9, 1.5, 4.0, 1.3, 4.6, 1.5, 4.5, 1.3, 4.7, 1.6, 3.3, 1.0, 4.6, 1.3, 3.9, 1.4, 3.5, 1.0, 4.2, 1.5, 4.0, 1.0, 4.7, 1.4, 3.6, 1.3, 4.4, 1.4, 4.5, 1.5, 4.1, 1.0, 4.5, 1.5, 3.9, 1.1, 4.8, 1.8, 4.0, 1.3, 4.9, 1.5, 4.7, 1.2, 4.3, 1.3, 4.4, 1.4, 4.8, 1.4, 5.0, 1.7, 4.5, 1.5, 3.5, 1.0, 3.8, 1.1, 3.7, 1.0, 3.9, 1.2, 5.1, 1.6, 4.5, 1.5, 4.5, 1.6, 4.7, 1.5, 4.4, 1.3, 4.1, 1.3, 4.0, 1.3, 4.4, 1.2, 4.6, 1.4, 4.0, 1.2, 3.3, 1.0, 4.2, 1.3, 4.2, 1.2, 4.2, 1.3, 4.3, 1.3, 3.0, 1.1, 4.1, 1.3, 6.0, 2.5, 5.1, 1.9, 5.9, 2.1, 5.6, 1.8, 5.8, 2.2, 6.6, 2.1, 4.5, 1.7, 6.3, 1.8, 5.8, 1.8, 6.1, 2.5, 5.1, 2.0, 5.3, 1.9, 5.5, 2.1, 5.0, 2.0, 5.1, 2.4, 5.3, 2.3, 5.5, 1.8, 6.7, 2.2, 6.9, 2.3, 5.0, 1.5, 5.7, 2.3, 4.9, 2.0, 6.7, 2.0, 4.9, 1.8, 5.7, 2.1, 6.0, 1.8, 4.8, 1.8, 4.9, 1.8, 5.6, 2.1, 5.8, 1.6, 6.1, 1.9, 6.4, 2.0, 5.6, 2.2, 5.1, 1.5, 5.6, 1.4, 6.1, 2.3, 5.6, 2.4, 5.5, 1.8, 4.8, 1.8, 5.4, 2.1, 5.6, 2.4, 5.1, 2.3, 5.1, 1.9, 5.9, 2.3, 5.7, 2.5, 5.2, 2.3, 5.0, 1.9, 5.2, 2.0, 5.4, 2.3, 5.1, 1.8];

        let kmean = KMeans::new(samples, 150, 2);
        let mut rnd = rand::rngs::StdRng::seed_from_u64(1);
        let res = kmean.kmeans_minibatch(30, 3, 100, KMeans::init_kmeanplusplus, &mut rnd);

        // SHOULD solution
        let should_assignments = vec![1usize, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 2, 2, 2, 0, 2, 2, 0, 0, 2, 2, 2, 2, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2];
        let should_centroid_distances = vec![0.0052691246, 0.0052691246, 0.027129695, 0.0034085654, 0.0052691246, 0.082943276, 0.006897025, 0.0034085654, 0.0052691246, 0.02178067, 0.0034085654, 0.021548016, 0.023641229, 0.14922288, 0.06899021, 0.026664365, 0.050385494, 0.006897025, 0.061315376, 0.0050364654, 0.059687477, 0.026664365, 0.21271135, 0.124571174, 0.19596632, 0.021548016, 0.044803813, 0.0034085654, 0.0052691246, 0.021548016, 0.021548016, 0.026664365, 0.02178067, 0.0052691246, 0.0034085654, 0.06899021, 0.027129695, 0.023641229, 0.027129695, 0.0034085654, 0.028757595, 0.028757595, 0.027129695, 0.14805962, 0.21922211, 0.006897025, 0.021548016, 0.0052691246, 0.0034085654, 0.0052691246, 0.12008819, 0.03325139, 0.31039473, 0.13335297, 0.072537154, 0.029782018, 0.16355759, 1.2631483, 0.06906778, 0.20580173, 0.8817198, 0.035394013, 0.2781489, 0.12008819, 0.57620984, 0.002230895, 0.03325139, 0.21743473, 0.03325139, 0.29059765, 0.36631304, 0.13335297, 0.31039473, 0.15661879, 0.011210372, 0.002230895, 0.1993743, 0.51314986, 0.03325139, 0.8817198, 0.39131197, 0.5802914, 0.24233234, 0.56726956, 0.03325139, 0.064986095, 0.13182288, 0.010496214, 0.07263882, 0.13335297, 0.038761493, 0.060802463, 0.16161823, 1.2631483, 0.03192464, 0.060189918, 0.03192464, 0.011210372, 1.9170254, 0.07263882, 0.28167185, 0.37486935, 0.045805182, 0.08100438, 0.029271454, 0.8326073, 0.116720796, 0.44780698, 0.08580509, 0.35407212, 0.35073593, 0.17966977, 0.03620378, 0.47833547, 0.45420238, 0.20313612, 0.10860403, 1.040874, 1.521542, 0.42968044, 0.052737623, 0.625935, 1.0291408, 0.46559876, 0.001004454, 0.17060572, 0.36631304, 0.46559876, 0.008604134, 0.23407185, 0.19887257, 0.5119404, 0.024470747, 0.56896615, 0.457538, 0.22233891, 0.116203986, 0.10860403, 0.36631304, 0.08380338, 0.116203986, 0.3983357, 0.37486935, 0.09753835, 0.18447083, 0.2907361, 0.5024689, 0.24313635, 0.13553655, 0.41900277];
        let should_centroids = vec![4.353571, 1.3913265, 1.4593028, 0.24186051, 5.6879983, 2.070667];
		let should_centroid_frequency = vec![56, 50, 44];

        assert_eq!(res.distsum, 31.670727);
        assert_eq!(res.sample_dims, LANES);
        assert_eq!(res.assignments, should_assignments);
        assert_eq!(res.centroid_distances, should_centroid_distances);
        assert_eq!(res.centroids, should_centroids);
		assert_eq!(res.centroid_frequency, should_centroid_frequency);
    }
}